#!/usr/bin/python
# Copyright (c) 2012, Stephen J. Leary
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met: 
# 
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer. 
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution. 
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 
# The views and conclusions contained in the software and documentation are those
# of the authors and should not be interpreted as representing official policies, 
# either expressed or implied, of the FreeBSD Project.

import sys,os,os.path
import getopt
from struct import unpack

widths = {8:"B", 16:"H", 32:"L", 64:"Q"}

def usage():
	"""Prints the usage string"""
	usagetext = """bin2mif (c) 2013 Stephen J. Leary
Usage: bin2mif  [-a] [-w <width>] [-e <endian>] <filename> 
Program outputs a hex MIF file to stdout.
Defaults are width = 8 and big endian unless specified.
"""
	sys.stderr.write(usagetext)

def getWidth(arg):
	global widths
	try:
		width = int(arg)
	except:
		usage()
		sys.stderr.write("ERROR: Could not width parameter to an integer.")
		sys.exit(1)
	
	if not width in widths.keys():
		sys.stderr.write("ERROR: invalid width parameter. supported widths are: " + str(widths.keys()) + "\n")
		sys.exit(1)
	
	return width
	
def getEndian(arg):
	
	if arg.lower() == "little":
		return "<"
	elif arg.lower() == "l":
		return "<"
	elif arg.lower() == "big":
		return ">"
	elif arg.lower() == "b":
		return ">"
	else:
		sys.stderr.write("""ERROR: invalid endian parameter. Values are "big","b","little" or "l" """)

try:		
	optlist, args = getopt.getopt(sys.argv[1:], 'w:e:h:A')
except getopt.GetoptError as e:
	print e
	sys.exit(1)
	

# if there are no more args then there is no file specified.
if len(args) != 1:
	usage()
	sys.stderr.write("Wrong number of arguments.\n")
	sys.exit(1)
	
fileName = args[0]

altera = False
width = 8
endian = ">"

for opt, arg in optlist:
	if opt == "-A":
		altera = True
	if opt == "-w":
		width = getWidth(arg)
	elif opt == "-h":
		usage()
		sys.exit(0)
	elif opt == "-e":
		endian = getEndian(arg)

# the number of bytes we need to read is the width divided by 8
readLen = width/8

if not os.path.exists(fileName):
	
	usage()

	sys.stderr.write("ERROR: The specified input file could not be found.\n")

	sys.exit(2)

f = open(fileName)

# generate the format string.
widthFormat = "%0"+str(readLen*2)+"x;"

depth = 0
content = ""

while True:
    bytes = f.read(readLen)
    if bytes == "":
        break
    n = unpack(endian + widths[width], bytes)
    unpacked = n[0] % 2**width           
    if altera:
	    content = content + "%04x: " % (depth)
    content = content + (widthFormat % unpacked) + "\n"
    depth += 1

# header
header = ""
header = header + "--  Memory Initialization File\n"
header = header + "--  Generated by bin2mif\n"
header = header + "--  From: %s\n\n" % fileName
header = header + "DEPTH = %d;\n" % depth
header = header + "WIDTH = %d;\n\n" % width
header = header + "ADDRESS_RADIX = HEX;\n"
header = header + "DATA_RADIX = HEX;\n\n"
header = header + "CONTENT\n  BEGIN\n"

# footer
footer = "  END;\n"


if altera:
	print header
print content
if altera:
	print footer

f.close()

